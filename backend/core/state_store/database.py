import sqlite3
import os


def init_db(db_path: str) -> None:
    """
    Creates the SQLite database file and all required tables if they do not
    already exist. Safe to call every time the server starts — CREATE TABLE IF
    NOT EXISTS means it is a no-op when the database is already set up correctly.

    The database file itself is created automatically by sqlite3.connect() if it
    does not exist yet, as long as the parent directory exists.
    """

    # Ensure the parent directory (i.e. data/) exists before sqlite3 tries to
    # create the file. os.makedirs() with exist_ok=True is safe to call even if
    # the directory is already there.
    os.makedirs(os.path.dirname(db_path), exist_ok=True)

    # Connect to (or create) the database file.
    # Using a context manager (with statement) ensures the connection is properly
    # closed even if an exception occurs during table creation.
    with get_connection(db_path) as conn:

        # subjects — a simple registry of known subjects (astronauts / participants).
        # Populated the first time a subject's data is encountered.
        # 'notes' is nullable (no NOT NULL constraint) — it is optional free text.
        conn.execute("""
            CREATE TABLE IF NOT EXISTS subjects (
                subject_id  TEXT PRIMARY KEY,
                created_at  TEXT NOT NULL,
                notes       TEXT
            )
        """)

        # snapshots — metadata for every point-in-time cross-sectional snapshot
        # generated by the system. The full snapshot JSON lives on the filesystem
        # in data/snapshots/{subject_id}/; this table stores only the metadata
        # needed for listing and linking to those files.
        # 'marker_ids' stores a JSON array as a plain TEXT string, e.g. '["vo2max"]'.
        # SQLite has no native array type; JSON-in-TEXT is the standard workaround.
        conn.execute("""
            CREATE TABLE IF NOT EXISTS snapshots (
                snapshot_id  TEXT PRIMARY KEY,
                subject_id   TEXT NOT NULL,
                requested_at TEXT NOT NULL,
                target_time  TEXT NOT NULL,
                marker_ids   TEXT NOT NULL
            )
        """)

        # timegraph_reports — metadata for every time-graph trajectory report.
        # Again, the full report JSON lives on the filesystem in data/reports/;
        # this table stores only the parameters and identifiers needed for lookup.
        # All zone boundary and fitting parameters are stored here so a report can
        # be re-identified and described without opening the JSON file.
        conn.execute("""
            CREATE TABLE IF NOT EXISTS timegraph_reports (
                report_id                TEXT PRIMARY KEY,
                subject_id               TEXT NOT NULL,
                marker_id                TEXT NOT NULL,
                module_id                TEXT NOT NULL,
                requested_at             TEXT NOT NULL,
                timeframe_from           TEXT NOT NULL,
                timeframe_to             TEXT NOT NULL,
                polynomial_degree        INTEGER NOT NULL,
                healthy_min              REAL NOT NULL,
                healthy_max              REAL NOT NULL,
                vulnerability_margin_pct REAL NOT NULL
            )
        """)

        # Commit is handled automatically by the context manager when the
        # 'with' block exits without an exception.


def get_connection(db_path: str) -> sqlite3.Connection:
    """
    Opens and returns a connection to the SQLite database at db_path.

    row_factory is set to sqlite3.Row so that query results can be accessed by
    column name (e.g. row["subject_id"]) in addition to by index (row[0]).
    This makes downstream code much more readable and less fragile to column
    order changes.

    The caller is responsible for closing the connection. When used as a context
    manager ('with get_connection(...) as conn'), sqlite3 automatically commits
    on success and rolls back on exception — but does NOT close the connection.
    Close it explicitly when you are done, or use contextlib.closing().
    """

    conn = sqlite3.connect(db_path)

    # sqlite3.Row is a built-in row factory that makes columns accessible by name.
    # Without this, rows are plain tuples and you must use positional indexing.
    conn.row_factory = sqlite3.Row

    return conn
